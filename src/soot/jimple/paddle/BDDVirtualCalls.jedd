/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003, 2004 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.paddle;
import soot.*;
import soot.util.*;
import soot.jimple.paddle.queue.*;
import soot.jimple.paddle.bdddomains.*;
import java.util.*;

/** Resolves virtual calls based on the actual type of the receiver.
 * @author Ondrej Lhotak
 */
public class BDDVirtualCalls extends AbsVirtualCalls
{ 
    BDDVirtualCalls( Rvarc_var_objc_obj pt,
            Rvar_srcm_stmt_dtp_signature_kind receivers,
            Rvar_srcm_stmt_tgtm specials,
            Qvarc_var_objc_obj_srcm_stmt_kind_tgtm out,
            Qsrcc_srcm_stmt_kind_tgtc_tgtm statics,
            AbsP2Sets p2sets
        ) {
        super( pt, receivers, specials, out, statics, p2sets );
        for( Iterator clIt = Scene.v().getClasses().iterator(); clIt.hasNext(); ) {
            final SootClass cl = (SootClass) clIt.next();
            for( Iterator mIt = cl.getMethods().iterator(); mIt.hasNext(); ) {
                final SootMethod m = (SootMethod) mIt.next();
                if( m.isAbstract() ) continue;
                declaresMethod |= new{
                        m.getDeclaringClass().getType()=>type,
                        m.getNumberedSubSignature()=>signature,
                        m=>method };
            }
        }
        for( Iterator clsIt = Scene.v().dynamicClasses().iterator(); clsIt.hasNext(); ) {
            final SootClass cls = (SootClass) clsIt.next();
            for( Iterator clinitIt = EntryPoints.v().clinitsOf(cls).iterator(); clinitIt.hasNext(); ) {
                final SootMethod clinit = (SootMethod) clinitIt.next();
                dynamicClinits |= new{clinit=>tgtm};
            }
        }
    }

    private int lastVarNode = 1;
    private int lastAllocNode = 1;
    private <var:V1, type> varNodes;
    private <obj, type> allocNodes;
    private <kind> virtual = new{Kind.VIRTUAL=>kind} | new{Kind.INTERFACE=>kind} | new{Kind.PRIVILEGED=>kind} | new{Kind.INVOKE_FINALIZE=>kind};
    private <type> threads = 0B;
    private void updateNodes() {
        <obj, tgtm> newStringConstants = 0B;
        <obj> newNonStringConstants = 0B;

        // update varnodes
        for( ; lastVarNode <= PaddleNumberers.v().varNodeNumberer().size();
            lastVarNode++ ) {
            VarNode vn = (VarNode) PaddleNumberers.v().varNodeNumberer().get(lastVarNode);
            varNodes |= new{ vn=>var, vn.getType()=>type };
        }

        for( ; lastAllocNode <= PaddleNumberers.v().allocNodeNumberer().size();
            lastAllocNode++ ) {
            AllocNode an = (AllocNode) PaddleNumberers.v().allocNodeNumberer().get(lastAllocNode);
            allocNodes |= new{ an=>obj, an.getType()=>type };

            if( an instanceof StringConstantNode ) {
                StringConstantNode scn = (StringConstantNode) an;
                String constant = scn.getString();
                if( constant.charAt(0) == '[' ) {
                    if( constant.length() > 1 && constant.charAt(1) == 'L' 
                        && constant.charAt(constant.length()-1) == ';' ) {
                            constant = constant.substring(2,constant.length()-1);
                    } else constant = null;
                }
                if( constant != null && Scene.v().containsClass(constant)) {
                    SootClass cls = Scene.v().getSootClass(constant);
                    for( Iterator methodIt = EntryPoints.v().clinitsOf(cls).iterator(); methodIt.hasNext(); ) {
                        final SootMethod method = (SootMethod) methodIt.next();
                        newStringConstants |= new{ an=>obj, method=>tgtm };
                    }
                }
            } else {
                newNonStringConstants |= new{an=>obj};
            }
        }
        threads = (subt=>type)
            hier.subtypeRelation(){supt} <> new{clRunnable=>type}{type};
        stringConstants |= newStringConstants;
        nonStringConstants |= newNonStringConstants;
        newClinitTargets |= 
            newStringConstants | (newNonStringConstants{} >< dynamicClinits{});
    }
    protected final RefType clRunnable = RefType.v("java.lang.Runnable");
        
    private <obj, tgtm> stringConstants = 0B;
    private <obj:H1> nonStringConstants = 0B;
    private <obj, tgtm> newClinitTargets = 0B;
    private <obj, tgtm> clinitTargets = 0B;
    private <tgtm> dynamicClinits = 0B;
    private final NumberedString sigClinit = Scene.v().getSubSigNumberer().
        findOrAdd( "void <clinit>()" );
    
    private <type, signature, method> targets = 0B;
    private <type, signature, method> declaresMethod = 0B;
    private BDDHierarchy hier = PaddleScene.v().BDDHierarchy();

    private <varc, var, objc, obj> newPt = 0B;
    private <varc, var, objc, obj> allPt = 0B;
    private <varc, var, obj> allPtNoObjc = 0B;
    private <var, srcm, stmt, dtp, signature, kind> newRcv = 0B;
    private <var, srcm, stmt, dtp, signature, kind> allRcv = 0B;
    private <var, srcm, stmt, tgtm> newSpc = 0B;
    private <var, srcm, stmt, tgtm> allSpc = 0B;

    private boolean change;
    public boolean update() {
        change = false;

        updateNodes();

        newPt = pt.get();
        allPt |= newPt;
        allPtNoObjc |= (objc=>) newPt;

        newRcv = receivers.get();
        allRcv |= newRcv;

        newSpc = specials.get();
        allSpc |= newSpc;

        // update receivers
        updateClinits();
        updateVirtuals();

        updateSpecials();

        return change;
    }

    private <var, srcm, stmt, kind> clinits;
    private <srcc, var, tgtm> tgtMethods;
    private void updateClinits() {
        clinits |= (dtp=>, signature=>) newRcv{kind} >< new{Kind.CLINIT=>kind}{kind};

        tgtMethods |=
            ((varc=>srcc, objc=>) allPt){obj} <> newClinitTargets{obj} |
            ((varc=>srcc, objc=>) newPt){obj} <> clinitTargets{obj};

        clinitTargets |= newClinitTargets;
        newClinitTargets = 0B;

        <srcc, srcm, stmt, kind, tgtc, tgtm> newStatics =
            tgtMethods{var} <> clinits{var}{} 
                         >< new{null=>tgtc}{};
        statics.add( newStatics );
        if( newStatics != 0B ) change = true;
    }
    private <varc, var, objc, obj, srcm, stmt, tgtm> resolvedSpecials = 0B;
    private void updateSpecials() {

        <varc, var, objc, obj, srcm, stmt, tgtm> newSpecials =
            newPt{var} >< allSpc{var}
            | allPt{var} >< newSpc{var};

        newSpecials -= resolvedSpecials;
        resolvedSpecials |= newSpecials;

        out.add( newSpecials{} >< new{Kind.SPECIAL=>kind}{} );
        if( newSpecials != 0B ) change = true;
    }

    private <var, srcm, stmt, type, kind, tgtm> callSiteTargets = 0B;
    private <var, dtp, signature> rcvSigs = 0B;
    private <var, dtp, signature> threadRcvSigs = 0B;
    private <var, srcm, stmt, dtp, signature, kind> rcv = 0B;
    private <varc, var, objc, obj, type> allVarCtxtPt = 0B;
    private <var, type> allPtTypes = 0B;
    private void updateVirtuals() {
        <var, srcm, stmt, dtp, signature, kind> newVirtRcv = 
            newRcv{kind} >< (virtual|new{Kind.THREAD=>kind}){kind};
        rcv |= newVirtRcv;

        <var, dtp, signature, kind> sigs = (srcm=>, stmt=>) newVirtRcv;
        <var, dtp, signature> newRcvSigs = sigs{kind} <> virtual{kind};
        rcvSigs |= newRcvSigs;
        <var, dtp, signature> newThreadRcvSigs = sigs{kind} <>
                               new{Kind.THREAD=>kind}{kind};
        threadRcvSigs |= newThreadRcvSigs;

        // resolve new points-to sets
        <var, type> ptTypes = allocNodes{obj} <> (varc=>, objc=>) newPt{obj}; 

        <type, dtp, signature> newTypes = ptTypes{var} <> rcvSigs{var};

        newTypes |= (ptTypes{type} >< threads{type}){var} <> threadRcvSigs{var};

        allPtTypes |= ptTypes;
        newTypes |= allPtTypes{var} <> newRcvSigs{var};
        newTypes |= (allPtTypes{type} >< threads{type}){var} <>
                                    newThreadRcvSigs{var};

        // close under AnySubType; that is, if the receiver is AnySubType(t),
        // replace it with all subtypes of t
        hier.update();
        newTypes |= newTypes{type} <> hier.anySub(){anyst};

        // only resolve concrete types
        newTypes = newTypes{type} >< hier.concrete(){type};

        // if we've resolved them already, don't resolve them again
        <signature, type> typesToResolve = ((dtp=>)newTypes) - ((method=>)targets);

        // for each tuple [t, s], make it [t, s, t].
        <subt, signature, supt> toResolve = (type=>subt, type=>supt) typesToResolve;

        <type, signature, method> newTargets = 0B;

        do {
            // figure out which receivers are already resolved (if the
            // corresponding class already declares the method)
            <subt, signature, supt, method> resolved =
                toResolve {supt, signature} >< declaresMethod {type, signature};

            // remove resolved ones
            toResolve -= (method=>) resolved;

            // add resolved ones to targets
            newTargets |= (subt=>type, supt=>) resolved;

            // move one step up the hierarchy for the other receiver types
            toResolve =                          toResolve {supt} 
                <> (supt=>T3) (hier.extend()|hier.array()) {subt};
        } while( toResolve != 0B );


        <varc, var, objc, obj, type> typedPt = allocNodes{obj}><newPt{obj};

        // close typedPt under AnySubType
        typedPt |= typedPt{type} <> hier.anySub(){anyst};
        <varc, var, dtp, objc, obj, type> varCtxtPt =
            typedPt{var} >< (type=>dtp) varNodes{var};

        // Weed out types coming from AnySubType that are not compatible
        // with the declared type of the variable.
        varCtxtPt =         varCtxtPt{type, dtp} 
            >< hier.subtypeRelation(){subt, supt};

        // Weed out non-concrete actual types.
        varCtxtPt = varCtxtPt{type} >< hier.concrete(){type};

        allVarCtxtPt |= (dtp=>) varCtxtPt;

        <var, srcm, stmt, dtp, type, kind, tgtm> newCallSiteTargets =
            newVirtRcv{signature} <> (method=>tgtm) targets{signature}
            | rcv{signature} <> (method=>tgtm) newTargets{signature};

        targets |= newTargets;

        // If the dtp is null, it means we don't know it, so allow anything
        newCallSiteTargets = newCallSiteTargets{type, dtp}
                      >< hier.subtypeRelation(){subt, supt}
                    | newCallSiteTargets{dtp} >< new{null=>dtp}{dtp};

        callSiteTargets |= (dtp=>) newCallSiteTargets;

        <varc, var, objc, obj, srcm, stmt, kind, tgtm> newVirtuals =
            (type=>) (
                             (dtp=>) varCtxtPt{type, var}
                            >< callSiteTargets{type, var} );
        newVirtuals |= 
            (type=>) (      allVarCtxtPt{type, var}
            >< (dtp=>)newCallSiteTargets{type, var});

        out.add( newVirtuals );
        if( newVirtuals != 0B ) change = true;
    }
}
     

