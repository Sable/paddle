/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003, 2004 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.paddle;
import soot.*;
import soot.util.queue.*;
import java.util.*;
import soot.options.PaddleOptions;
import soot.jimple.paddle.bdddomains.*;
import soot.jimple.paddle.queue.*;
import jedd.*;

/** Propagates points-to sets along pointer assignment graph using BDDs.
 * @author Ondrej Lhotak
 */

public class PropBDD extends AbsPropagator {
    public PropBDD(  Rsrcc_src_dstc_dst simple, Rsrcc_src_fld_dstc_dst load, Rsrcc_src_dstc_dst_fld store,
            Robjc_obj_varc_var alloc, Qvarc_var_objc_obj propout, AbsPAG pag ) {
        super( simple, load, store, alloc, propout, pag );
    }

    /*package*/ <varc, var, objc, obj> pt = 0B;
    /*package*/ <basec, base, fld, objc, obj> fieldPt = 0B;

    protected <varc, var, objc, obj> typeFilter() {
        final <varc, objc> allContexts = 1B;
        return PaddleScene.v().tm.get(){} >< allContexts{};
    }

    protected <varc, var, objc, obj> outputtedPt = 0B;
    protected void outputPt( <varc, var, objc, obj> pt ) {
        <varc, var, objc, obj> toOutput = pt - outputtedPt;
        if( toOutput == 0B ) return;
        ptout.add( toOutput );
        outputtedPt |= toOutput;
    //    PaddleScene.v().updateCallGraph();
    }

    /** Propagate points-to relation pt over assignments simple. */
    protected <varc:C1, var, objc:CH1, obj> propSimple(
        <varc:C1, var, objc:CH1, obj> pt,
        <srcc:C1, src, dstc:C2, dst> simple ) {

        <varc, var, objc, obj> ret = 0B;
        while( true ) {
            pt = typeFilter() &
                ((dstc=>varc, dst=>var) 
                                       simple {srcc, src} 
                                        <> pt {varc, var} );
            pt -= ret;
            if(pt == 0B) break;
            ret |= pt;
        }
        return ret;
    }

    /** Propagate points-to relation pt over stores stores pointing to storePt. */
    protected <basec:CH1, base:H1, fld, objc:CH2, obj:H2> propStore(
        <varc, var, objc, obj> pt,
        <srcc, src, fld, dstc, dst> store,
        <varc, var, objc, obj> storePt ) {

        <objc, obj, varc, var, fld> objectsBeingStored =
            (dstc=>varc, dst=>var) store {srcc, src} 
                                   <> pt {varc, var};
                                        
        return               objectsBeingStored {varc, var} 
            <> (objc=>basec, obj=>base) storePt {varc, var};
    }

    /** Propagate points-to relation fpt over loads pointing to loadPt. */
    protected <varc, var, objc, obj> propLoad(
        <basec, base, fld, objc, obj> fpt,
        <srcc, src, fld, dstc, dst> load,
        <varc, var, objc, obj> loadPt ) {

        <basec, base, fld, dstc, dst> loadsFromHeap;
        loadsFromHeap =                   load{srcc, src} 
            <> (objc=>basec, obj=>base) loadPt{varc, var};

        return (dstc=>varc, dst=>var) loadsFromHeap {basec,base,fld} 
                                             <> fpt {basec,base,fld};
    }

    public boolean fieldUpdate() {
        <varc, var, objc, obj> oldPt = pt;

        fieldPt |= propStore( pt, pag.allStore().get(), pt );
        pt |= propLoad( fieldPt, pag.allLoad().get(), pt ) & typeFilter();

        outputPt( pt );
        return pt != oldPt;
    }

    public boolean update() {
        <varc, var, objc, obj> oldPt = pt;

        pt |= newAlloc.get() & typeFilter();
        pt |= propSimple( pt, pag.allSimple().get() ) & typeFilter();
        outputPt( pt );


        if( PaddleScene.v().options().verbose() ) {
                G.v().out.println( "Major iteration: " );
        }

        return pt != oldPt;
    }

    private BDDP2Sets p2sets = new BDDP2Sets(this);
    public AbsP2Sets p2sets() { return p2sets; }

    /* End of public methods. */
    /* End of package methods. */

}



