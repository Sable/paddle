/* Soot - a J*va Optimization Framework
 * Copyright (C) 2004, 2005 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.paddle;
import soot.*;
import soot.jimple.*;
import soot.jimple.paddle.queue.*;
import soot.jimple.paddle.bdddomains.*;
import java.util.*;
import soot.jimple.toolkits.callgraph.*;

/** Analysis for AspectJ cflow optimization.
 * @author Ondrej Lhotak
 */
public class BDDCflow
{ 
    public static final boolean DEBUG = false;
    public BDDCflow() {
        stmtMethod = 0B;
        if(DEBUG) G.v().out.println("Getting call graph");
        for( Iterator scIt = Scene.v().getApplicationClasses().iterator(); scIt.hasNext(); ) {
            final SootClass sc = (SootClass) scIt.next();
            for( Iterator mIt = sc.getMethods().iterator(); mIt.hasNext(); ) {
                final SootMethod m = (SootMethod) mIt.next();
                if( m.hasActiveBody() ) {
                    for( Iterator sIt = m.getActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
                        final Stmt s = (Stmt) sIt.next();
                        Scene.v().getUnitNumberer().add(s);
                        stmtMethod |= new{s=>stmt, m=>method};
                    }
                }
            }
        }
        <kind> wantedKinds =
              new{Kind.STATIC=>kind} 
            | new{Kind.VIRTUAL=>kind}
            | new{Kind.INTERFACE=>kind}
            | new{Kind.SPECIAL=>kind}
            | new{Kind.CLINIT=>kind}
            | new{Kind.PRIVILEGED=>kind}
            | new{Kind.NEWINSTANCE=>kind};

        <srcm:MS, stmt:ST, kind:KD, tgtm:MT> callEdges = 0B;

        AbsCallGraph cg = Results.v().callGraph();
        if( cg == null ) {
            if(DEBUG) G.v().out.println("No Paddle call graph -- using Soot one.");
            for( Iterator eIt = Scene.v().getCallGraph().listener(); eIt.hasNext(); ) {
                final Edge e = (Edge) eIt.next();
                callEdges |= new{e.src()=>srcm, e.srcStmt()=>stmt,
                    e.kind()=>kind, e.tgt()=>tgtm};
            }
        } else {
            if(DEBUG) G.v().out.println("Using Paddle call graph.");
            callEdges = cg.ciEdges().get();
        }

        callGraph = callEdges{kind} <> wantedKinds{kind};
        if(DEBUG) G.v().out.println("Done getting call graph");
    }
    private <stmt, method> stmtMethod;
    <stmt, method> stmtMethod() { return stmtMethod; }
    private <srcm, stmt, tgtm> callGraph;
    <srcm, stmt, tgtm> callGraph() { return callGraph; }
}
